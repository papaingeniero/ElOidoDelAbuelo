v1.0-dev.13 Feature: Reproducci√≥n Exclusiva (Solo-Play)

## üöÄ Fase 3.4: Reproducci√≥n Exclusiva (Solo-Play) v1.0-dev.13 | 20-Feb-2026
### üìú El Problema
En el Centro de Mando Web, si el usuario abr√≠a m√∫ltiples alertas del historial a la vez, o si le daba al bot√≥n "Escuchar en Vivo" sin detener la alerta previa, la API HTML5 colisionaba los audios generando una cacofon√≠a incomprensible de m√∫ltiples or√≠genes simult√°neos.

### üõ†Ô∏è La Soluci√≥n
1. **Event Delegation en Fase de Captura**: Se inyect√≥ en `index.html` un listener global `document.addEventListener('play', ..., true)`. Usamos *captura* porque los eventos de media (`play`, `pause`) no burbujean hacia arriba en el DOM de forma natural.
2. **Silenciamiento DOM**: Cuando cualquier `<audio>` dispara el evento, el c√≥digo itera sobre todos los elementos `<audio>` de la p√°gina invocando su m√©todo `.pause()`, excepto para aquel que origin√≥ el evento.
3. **Cross-Silencing (Historial vs Live)**: Si el Objeto `Audio` global (`liveAudio`) est√° instanciado, se mata y resetea la UI a OFF. Sim√©tricamente, al activar manualmente "Escuchar en Vivo", recorremos el DOM apagando de forma preemptiva cualquier alerta que estuviera sonando (con `a.pause()`).

### üéì Lecciones Aprendidas
- Para interceptar eventos de medios (`play`, `pause`) creados din√°micamente sin atar listeners a cada nodo individual, la delegaci√≥n de eventos v√≠a la fase de *capturing* (tercer argumento `true` en `addEventListener`) es el patr√≥n m√°s limpio y de menor consumo de memoria para Vanilla JS.
