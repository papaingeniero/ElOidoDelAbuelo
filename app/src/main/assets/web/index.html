<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Centro de Mando - O√≠do del Abuelo</title>
    <style>
        :root {
            --bg-color: #121212;
            --surface-color: #1f1f1f;
            --text-color: #ffffff;
            --text-muted: #888888;
            --primary-color: #d32f2f;
            --primary-dark: #9a0007;
            --status-green: #03dac6;
            --status-yellow: #ffb300;
            --status-red: #d32f2f;
            --status-gray: #757575;
            --item-bg: #2c2c2c;
            --item-active: #3d3d3d;
            --max-amplitude: 32767;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .dashboard {
            background-color: var(--surface-color);
            border-radius: 12px;
            padding: 30px;
            width: 100%;
            max-width: 600px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            text-align: center;
        }

        h1 {
            margin-top: 0;
            font-size: 1.5rem;
            color: var(--primary-color);
            letter-spacing: 1px;
        }

        .status-badge {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9rem;
            text-transform: uppercase;
            margin-bottom: 25px;
            transition: all 0.3s ease;
            background-color: var(--status-gray);
            color: #fff;
        }

        .instrument-panel {
            margin-bottom: 20px;
            text-align: left;
        }

        .label-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .meter-bg {
            width: 100%;
            height: 30px;
            background-color: #333;
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        .meter-fill {
            height: 100%;
            width: 0%;
            background-color: var(--status-green);
            transition: width 0.1s linear, background-color 0.2s ease;
        }

        .threshold-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: rgba(255, 255, 255, 0.3);
            left: calc((10000 / 32767) * 100%);
            /* 10000 is default SPIKE_THRESHOLD */
            z-index: 10;
        }

        .threshold-marker::after {
            content: "Umbral";
            position: absolute;
            top: -20px;
            left: -20px;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.5);
        }

        .settings-btn {
            background-color: var(--primary-color);
            color: #fff;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            margin-bottom: 20px;
            font-weight: bold;
            transition: opacity 0.2s;
        }

        .settings-btn:hover {
            opacity: 0.8;
            background-color: var(--primary-dark);
        }

        /* LIVE BUTTON PULSE ANIMATION (El Ojo Style) */
        .live-btn-active {
            background-color: var(--status-red) !important;
            color: white !important;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(211, 47, 47, 0.7);
            }

            70% {
                transform: scale(1.05);
                box-shadow: 0 0 0 10px rgba(211, 47, 47, 0);
            }

            100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(211, 47, 47, 0);
            }
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 100;
            align-items: flex-start;
            /* Evitar que el centro exacto sature el Top-Bar */
            justify-content: center;
            padding-top: 60px;
            /* Separaci√≥n prudencial de la barra de navegaci√≥n del host */
        }

        .modal-content {
            background: #222222;
            padding: 25px 25px 60px 25px;
            border-radius: 12px;
            width: 85%;
            max-width: 400px;
            margin: 0 auto;
            color: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            max-height: 75vh;
            /* Evasi√≥n del error de Bottom-Bar / 100vh de Safari/Chrome m√≥vil */
            overflow-y: auto;
        }

        .modal-content h2 {
            margin-top: 0;
            color: var(--status-green);
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            font-size: 0.85rem;
            color: #aaa;
            margin-bottom: 5px;
        }

        .form-group input[type="number"],
        .form-group input[type="range"] {
            width: 100%;
            box-sizing: border-box;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 8px;
            border-radius: 4px;
        }

        .form-group input[type="checkbox"] {
            transform: scale(1.2);
        }

        .btn-row {
            display: flex;
            justify-content: space-between;
            margin-top: 25px;
        }

        .btn {
            padding: 10px 20px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-weight: bold;
        }

        .btn-save {
            background: #2e7d32;
            color: white;
            flex: 1;
            margin-right: 10px;
        }

        .btn-close {
            background: #c62828;
            color: white;
            flex: 1;
        }

        .history-panel {
            margin-top: 30px;
            background-color: var(--surface-color);
            border-radius: 12px;
            padding: 20px;
            width: 100%;
            max-width: 600px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            text-align: left;
        }

        .history-card {
            background-color: var(--item-bg);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
            border-left: 4px solid var(--status-gray);
            /* Cambiar√° din√°micamente */
            transition: transform 0.1s, background-color 0.2s;
        }

        .history-card:active {
            transform: scale(0.98);
            background-color: var(--item-active);
        }

        .history-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .history-date {
            font-weight: bold;
            font-size: 0.95rem;
            color: #fff;
        }

        .history-size {
            font-size: 0.8rem;
            color: #aaa;
        }

        audio {
            width: 100%;
            height: 35px;
            outline: none;
            border-radius: 20px;
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #555;
            transition: .3s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--status-green);
        }

        input:checked+.slider:before {
            transform: translateX(22px);
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.05);
            padding: 12px 15px;
            border-radius: 8px;
        }

        .setting-label {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        /* CSS para inmovilizar el Scroll principal */
        body.modal-open {
            overflow: hidden;
        }
    </style>
</head>

<body>

    <div class="dashboard">
        <h1>El O√≠do del Abuelo <span id="appVersion" style="font-size: 0.8rem; color: var(--status-gray);"></span></h1>
        <button class="settings-btn" onclick="openSettings()">‚öôÔ∏è Ajustes</button>

        <!-- HARDWARE TELEMETRY TOOLBAR -->
        <div id="telemetryToolbar"
            style="display: flex; justify-content: center; align-items: center; gap: 15px; margin: 5px auto 15px auto; background: rgba(255, 255, 255, 0.05); padding: 8px 15px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(4px); font-size: 0.85rem; font-weight: bold; width: fit-content; transition: all 0.3s;">
            <div style="display: flex; align-items: center; gap: 5px;">
                <span id="batteryIcon" style="transition: color 0.3s; font-size: 1.1rem;">üîã</span>
                <span id="batteryText" style="transition: color 0.3s; color: #fff;">--%</span>
            </div>
            <div style="width: 1px; height: 15px; background: rgba(255,255,255,0.2);"></div>
            <div style="display: flex; align-items: center; gap: 5px;">
                <span id="tempIcon" style="transition: color 0.3s; font-size: 1.1rem;">üå°Ô∏è</span>
                <span id="tempText" style="transition: color 0.3s; color: #fff;">--¬∞C</span>
            </div>
        </div>

        <br>
        <button id="btnRecMaster" class="pill-btn"
            style="display: block; width: 100%; margin: 10px 0 25px 0; text-align: center; font-size: 1.3rem; padding: 18px; background-color: var(--status-red); border: none; color: white; border-radius: 12px; font-weight: bold; cursor: pointer; transition: background 0.2s;"
            onclick="toggleContinuousRec()">
            ‚è∫Ô∏è GRABAR AHORA
        </button>

        <div class="instrument-panel">
            <button id="btnLive" class="settings-btn"
                style="background-color: var(--status-gray); display: block; width: 100%; margin-top: 10px; margin-bottom: 30px; text-align: center; font-size: 1.1rem; padding: 15px;"
                onclick="toggleLiveAudio()">üìª Escuchar en Vivo (OFF)</button>
            <div class="label-row">
                <span>Amplitud de Micr√≥fono</span>
                <span id="amplitudeValue">0</span>
            </div>
            <div class="meter-bg">
                <div id="vumeter" class="meter-fill"></div>
                <div class="threshold-marker"></div>
            </div>
        </div>
    </div>

    <div class="history-panel">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
            <h2 style="margin: 0; color: var(--primary-color);">Historial de Alertas</h2>
            <button class="settings-btn" style="margin: 0;" onclick="loadHistory()">üîÑ Actualizar</button>
        </div>
        <div id="historyContainer">
            <p style="text-align: center; color: #888; font-size: 0.9rem;">Cargando historial...</p>
        </div>
    </div>

    <!-- Modal de Ajustes -->
    <div id="settingsModal" class="modal">
        <div class="modal-content">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="margin: 0;">Ajustes del Centinela</h2>
                <button onclick="closeSettings()"
                    style="background: none; border: none; color: #888; font-size: 2rem; cursor: pointer; padding: 0; line-height: 1;">&times;</button>
            </div>

            <div class="setting-row">
                <div class="setting-label">
                    <strong style="color: #fff; font-size: 1.05rem;">Vigilancia Activa</strong>
                    <span style="font-size: 0.8rem; color: #aaa;">Encender/Apagar micr√≥fono celular.</span>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="inpMicEnabled" onchange="toggleShieldVisibility()">
                    <span class="slider"></span>
                </label>
            </div>

            <div class="setting-row" id="shieldRow">
                <div class="setting-label">
                    <strong style="color: #fff; font-size: 1.05rem;">Filtro Anti-Falsas Alarmas</strong>
                    <span style="font-size: 0.8rem; color: #aaa;">Obliga al micr√≥fono a escuchar varios tirones seguidos
                        para grabar.</span>
                </div>
                <label class="toggle-switch">
                    <input type="checkbox" id="inpShieldEnabled">
                    <span class="slider"></span>
                </label>
            </div>

            <div class="form-group">
                <label>Volumen m√≠nimo de disparo: <strong id="valSpike"
                        style="color:var(--status-green);">10000</strong></label>
                <input type="range" id="inpSpike" min="0" max="32767" value="10000"
                    oninput="document.getElementById('valSpike').innerText=this.value">
            </div>
            <div class="form-group">
                <label>Picos Consecutivos para saltar (REQUIRED_SPIKES)</label>
                <input type="number" id="inpRequired" min="1" max="10">
            </div>
            <div class="form-group">
                <label>SHIELD_WINDOW_MS (Ventana de Tolerancia MS)</label>
                <input type="number" id="inpWindow" min="100" max="5000">
            </div>
            <div class="form-group">
                <label>RECORD_DURATION_MS (Duraci√≥n Grabaci√≥n MS)</label>
                <input type="number" id="inpDuration" min="1000" max="60000">
            </div>
            <div class="form-group" style="margin-top: 20px; border-top: 1px solid #444; padding-top: 20px;">
                <label style="color: var(--status-red); font-weight: bold;">‚ö†Ô∏è ZONA DE PELIGRO</label>
                <button class="btn" style="background: var(--status-red); color: white; width: 100%; margin-top: 10px;"
                    onclick="deleteRecordings()">üóëÔ∏è Purgar Todo el Historial</button>
            </div>
            <div class="btn-row" style="padding-bottom: 100px;">
                <button class="btn btn-close" onclick="closeSettings()">Cancelar</button>
                <button class="btn btn-save" onclick="saveSettings()">Guardar</button>
            </div>
        </div>
    </div>

    <!-- Modal del Waveform Player -->
    <div id="waveformModal" class="modal">
        <div class="modal-content" style="max-height: 85vh; padding: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h2 id="waveTitle"
                    style="margin: 0; font-size: 1.1rem; color: var(--primary-color); word-break: break-all;">
                    Analizando...</h2>
                <button onclick="closeWaveform()"
                    style="background: none; border: none; color: #888; font-size: 2rem; cursor: pointer; padding: 0; line-height: 1;">&times;</button>
            </div>

            <div style="background: #111; border-radius: 8px; padding: 10px; margin-bottom: 15px; position: relative;">
                <canvas id="waveCanvas" width="400" height="120"
                    style="width: 100%; height: 120px; cursor: pointer; display: block;"></canvas>
                <!-- Mensaje de Carga Superpuesto -->
                <div id="waveLoading"
                    style="position: absolute; top:0; left:0; right:0; bottom:0; display:flex; justify-content:center; align-items:center; background: rgba(0,0,0,0.7); border-radius: 8px; font-weight: bold; color: var(--status-green);">
                    üîÑ Procesando Audio...
                </div>
            </div>

            <div style="text-align: center; margin-bottom: 15px; font-family: monospace; font-size: 1.2rem; color: #ccc;"
                id="waveTimeDisplay">
                00:00 / 00:00
            </div>

            <div style="display: flex; justify-content: center; gap: 15px; margin-bottom: 20px; align-items: center;">
                <button class="settings-btn" style="margin:0; padding: 10px 15px; font-size: 1.2rem;"
                    onclick="seekWaveform(-5)">‚èÆ -5s</button>
                <button id="wavePlayBtn" class="pill-btn"
                    style="background: var(--status-green); border: none; color: black; padding: 10px 25px; border-radius: 20px; font-weight: bold; font-size: 1.2rem; cursor: pointer;"
                    onclick="toggleWaveformPlay()">‚ñ∂Ô∏è PLAY</button>
                <button class="settings-btn" style="margin:0; padding: 10px 15px; font-size: 1.2rem;"
                    onclick="seekWaveform(5)">+5s ‚è≠</button>
            </div>
        </div>
    </div>

    <script>
        const MAX_AMPLITUDE = 32767;
        let latestConfig = {};

        // Reproducci√≥n exclusiva: Detener otros audios al reproducir uno nuevo
        document.addEventListener('play', function (e) {
            if (e.target.tagName === 'AUDIO') {
                // Pausar cualquier otro audio del historial
                document.querySelectorAll('audio').forEach(function (audioElement) {
                    if (audioElement !== e.target) {
                        audioElement.pause();
                    }
                });

                // Apagar el stream en vivo si estaba sonando
                if (liveAudioElement != null) {
                    toggleLiveAudio();
                }
            }
        }, true); // Usar fase de captura porque los eventos media no burbujean

        const vumeter = document.getElementById('vumeter');
        const statusBadge = document.getElementById('statusBadge');
        const amplitudeValue = document.getElementById('amplitudeValue');

        function updateDashboard() {
            fetch('/api/status')
                .then(response => {
                    if (!response.ok) throw new Error("Network response was not ok");
                    return response.json();
                })
                .then(data => {
                    const amp = data.currentAmplitude || 0;
                    const isRecording = data.isRecording;

                    const micEnabled = data.micEnabled !== undefined ? data.micEnabled : true;
                    const shieldEnabled = data.shieldEnabled !== undefined ? data.shieldEnabled : true;
                    const forceRecord = data.forceRecord || false;

                    latestConfig = data; // Almacenamos para rellenar el modal

                    if (data.version) {
                        document.getElementById('appVersion').textContent = data.version;
                        document.title = "El O√≠do del Abuelo - " + data.version;
                    }

                    // Hardware Telemetry
                    if (data.batteryPct !== undefined && data.tempCelsius !== undefined) {
                        const batText = document.getElementById('batteryText');
                        const batIcon = document.getElementById('batteryIcon');
                        const tempText = document.getElementById('tempText');
                        const tempIcon = document.getElementById('tempIcon');

                        if (batText && batIcon && tempText && tempIcon) {
                            batText.textContent = data.batteryPct + "%" + (data.isCharging ? " (AC)" : "");
                            if (data.isCharging) {
                                batText.style.color = "var(--status-green)";
                                batIcon.textContent = "‚ö°";
                            } else if (data.batteryPct <= 20) {
                                batText.style.color = "var(--status-red)";
                                batIcon.textContent = "ü™´";
                            } else {
                                batText.style.color = "#fff";
                                batIcon.textContent = "üîã";
                            }

                            tempText.textContent = data.tempCelsius.toFixed(1) + "¬∞C";
                            if (data.tempCelsius > 40) {
                                tempText.style.color = "var(--status-red)";
                                tempIcon.style.color = "var(--status-red)";
                            } else if (data.tempCelsius > 35) {
                                tempText.style.color = "orange";
                                tempIcon.style.color = "orange";
                            } else {
                                tempText.style.color = "#fff";
                                tempIcon.style.color = "inherit";
                            }
                        }
                    }

                    // Ajustar UI del threshold-marker
                    let currentSpikeThreshold = (data.SPIKE_THRESHOLD !== undefined) ? data.SPIKE_THRESHOLD : 10000;
                    document.querySelector('.threshold-marker').style.left = `calc((${currentSpikeThreshold} / 32767) * 100%)`;

                    // Actualizar texto num√©rico
                    amplitudeValue.textContent = Math.round(amp);

                    // Calcular porcentaje para ancho CSS
                    let percentage = (amp / MAX_AMPLITUDE) * 100;
                    if (percentage > 100) percentage = 100;
                    vumeter.style.width = percentage + '%';

                    // L√≥gica de colores y estados - V31
                    const btnRecMaster = document.getElementById('btnRecMaster');

                    if (!micEnabled) {
                        statusBadge.textContent = "Micr√≥fono Apagado";
                        statusBadge.style.backgroundColor = "var(--status-gray)";
                        vumeter.style.backgroundColor = "var(--status-gray)";
                        btnRecMaster.innerHTML = `‚ö†Ô∏è MICRO OFF EN AJUSTES`;
                        btnRecMaster.style.backgroundColor = "var(--status-gray)";
                    } else if (forceRecord) {
                        statusBadge.textContent = "Grabaci√≥n Continua";
                        statusBadge.style.backgroundColor = "var(--status-red)";
                        vumeter.style.backgroundColor = "var(--status-red)";

                        let timeStr = "00:00:00";
                        if (data.recordingStartTimestamp) {
                            const diff = Math.floor((Date.now() - data.recordingStartTimestamp) / 1000);
                            const h = String(Math.floor(diff / 3600)).padStart(2, '0');
                            const m = String(Math.floor((diff % 3600) / 60)).padStart(2, '0');
                            const s = String(diff % 60).padStart(2, '0');
                            timeStr = `${h}:${m}:${s}`;
                        }
                        btnRecMaster.innerHTML = `‚èπÔ∏è DETENER [${timeStr}]`;
                        btnRecMaster.style.backgroundColor = "#555";
                    } else if (isRecording) {
                        statusBadge.textContent = "Grabando Alarma";
                        statusBadge.style.backgroundColor = "var(--status-red)";
                        vumeter.style.backgroundColor = "var(--status-red)";
                        btnRecMaster.innerHTML = `‚è∫Ô∏è GRABAR AHORA`;
                        btnRecMaster.style.backgroundColor = "var(--status-red)";
                    } else {
                        statusBadge.textContent = shieldEnabled ? "Vigilando (Escudo ON)" : "Vigilando (Picos Directos)";
                        statusBadge.style.backgroundColor = "var(--primary-dark)";
                        btnRecMaster.innerHTML = `‚è∫Ô∏è GRABAR AHORA`;
                        btnRecMaster.style.backgroundColor = "var(--status-red)";

                        // V√∫metro din√°mico en escucha
                        if (amp > currentSpikeThreshold) {
                            vumeter.style.backgroundColor = shieldEnabled ? "var(--status-yellow)" : "var(--status-red)";
                        } else {
                            vumeter.style.backgroundColor = "var(--status-green)";
                        }
                    }
                })
                .catch(error => {
                    console.error('Error fetching status:', error);
                    statusBadge.textContent = "Sin Conexi√≥n";
                    statusBadge.style.backgroundColor = "var(--status-gray)";
                    vumeter.style.width = '0%';
                });
        }

        function openSettings() {
            document.getElementById('inpMicEnabled').checked = (latestConfig.micEnabled !== undefined) ? latestConfig.micEnabled : true;
            document.getElementById('inpShieldEnabled').checked = (latestConfig.shieldEnabled !== undefined) ? latestConfig.shieldEnabled : true;
            toggleShieldVisibility();

            document.getElementById('inpSpike').value = latestConfig.SPIKE_THRESHOLD ?? 10000;
            document.getElementById('valSpike').innerText = latestConfig.SPIKE_THRESHOLD ?? 10000;
            document.getElementById('inpRequired').value = latestConfig.REQUIRED_SPIKES ?? 3;
            document.getElementById('inpWindow').value = latestConfig.SHIELD_WINDOW_MS ?? 500;
            document.getElementById('inpDuration').value = latestConfig.RECORD_DURATION_MS ?? 15000;

            document.body.classList.add('modal-open');
            document.getElementById('settingsModal').style.display = 'flex';
        }

        function closeSettings() {
            document.body.classList.remove('modal-open');
            document.getElementById('settingsModal').style.display = 'none';
        }

        function toggleShieldVisibility() {
            const mic = document.getElementById('inpMicEnabled').checked;
            document.getElementById('shieldRow').style.opacity = mic ? '1' : '0.3';
            document.getElementById('shieldRow').style.pointerEvents = mic ? 'auto' : 'none';
        }

        function toggleContinuousRec() {
            if (latestConfig && latestConfig.micEnabled === false) {
                alert("‚ö†Ô∏è Active la [Vigilancia Activa] en Ajustes primero.");
                return;
            }
            const isForced = latestConfig && latestConfig.forceRecord;
            const newForceState = !isForced;

            fetch('/api/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ forceRecord: newForceState })
            }).then(res => res.json()).then(data => {
                if (data.status !== 'ok') alert("Error: " + data.message);
                updateDashboard();
            }).catch(err => alert("Error de red al activar/desactivar grabaci√≥n"));
        }

        function saveSettings() {
            const payload = {
                micEnabled: document.getElementById('inpMicEnabled').checked,
                shieldEnabled: document.getElementById('inpShieldEnabled').checked,
                SPIKE_THRESHOLD: parseInt(document.getElementById('inpSpike').value),
                REQUIRED_SPIKES: parseInt(document.getElementById('inpRequired').value),
                SHIELD_WINDOW_MS: parseInt(document.getElementById('inpWindow').value),
                RECORD_DURATION_MS: parseInt(document.getElementById('inpDuration').value)
            };

            fetch('/api/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
                .then(res => res.json())
                .then(data => {
                    if (data.status === 'ok') {
                        closeSettings();
                        updateDashboard();
                    } else {
                        alert("Error guardando: " + data.message);
                    }
                })
                .catch(err => alert("Error de red al guardar"));
        }

        function deleteRecordings() {
            if (!confirm("‚ö†Ô∏è ¬øPulsar el Bot√≥n del P√°nico? Se borrar√° TODO el historial permanentemente.")) return;

            fetch('/api/recordings', { method: 'DELETE' })
                .then(res => res.json())
                .then(data => {
                    if (data.status === 'ok') {
                        loadHistory();
                    } else {
                        alert("Error borrando: " + data.message);
                    }
                });
        }

        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function loadHistory() {
            fetch('/api/recordings')
                .then(r => r.json())
                .then(files => {
                    const list = document.getElementById('historyContainer');
                    list.innerHTML = '';
                    if (files.length === 0) {
                        list.innerHTML = '<div style="text-align:center; color:#888;">No hay grabaciones todav√≠a.</div>';
                        return;
                    }

                    files.forEach(f => {
                        const card = document.createElement('div');
                        card.className = 'history-card';

                        // Todo es rojo carmes√≠ base ya que WebServer no env√≠a maxAmplitude
                        card.style.borderLeftColor = 'var(--status-red)';

                        const dateObj = new Date(f.timestamp);
                        const dateStr = dateObj.toLocaleDateString() + ' ' + dateObj.toLocaleTimeString();

                        // Formatear tama√±o a KB o MB
                        const sizeKB = f.size / 1024;
                        const sizeStr = sizeKB > 1024 ? (sizeKB / 1024).toFixed(2) + ' MB' : sizeKB.toFixed(1) + ' KB';

                        card.innerHTML = `
                            <div class="history-card-header">
                                <span class="history-date">üö® ${dateStr}</span>
                                <span class="history-size">üìÅ ${sizeStr}</span>
                            </div>
                            <button class="settings-btn" style="display: block; width: 100%; margin-top: 10px; background: #333; padding: 12px; font-size: 1.05rem;" onclick="openWaveform('${f.name}')">üëÅÔ∏è Analizar Pista Auditiva</button>
                        `;
                        list.appendChild(card);
                    });
                })
                .catch(err => {
                    console.error("Error cargando historial:", err);
                    const list = document.getElementById('historyContainer');
                    list.innerHTML = '<p style="text-align: center; color: var(--status-red); font-size: 0.9rem;">Error de conexi√≥n.</p>';
                });
        }

        let liveAudioElement = null;

        function playLiveStream() {
            if (liveAudioElement) return;

            // Native HTML5 Audio Element for ADTS AAC Stream
            liveAudioElement = new Audio('/api/stream?' + new Date().getTime());
            liveAudioElement.crossOrigin = "anonymous";
            liveAudioElement.autoplay = true;
            // Previene el almacenamiento en cache agresivo del AAC inf√≠nito
            liveAudioElement.preload = "none";

            liveAudioElement.addEventListener('error', function (e) {
                console.error("Error en streaming AAC nativo", e);
                stopLiveStream();
            });

            liveAudioElement.play().catch(e => {
                console.error("Autoplay bloqueado:", e);
                alert("El navegador bloque√≥ la reproducci√≥n autom√°tica. Interact√∫e con la p√°gina.");
                stopLiveStream();
            });
        }

        function stopLiveStream() {
            if (liveAudioElement) {
                liveAudioElement.pause();
                liveAudioElement.src = "";
                liveAudioElement.load();
                liveAudioElement = null;
            }
            const btn = document.getElementById('btnLive');
            btn.textContent = "üìª Escuchar en Vivo (OFF)";
            btn.classList.remove('live-btn-active');
        }

        function toggleLiveAudio() {
            const btn = document.getElementById('btnLive');
            if (!liveAudioElement) {
                // Pausar cualquier audio del historial
                document.querySelectorAll('audio').forEach(a => {
                    if (a !== liveAudioElement) a.pause();
                });

                playLiveStream();
                btn.textContent = "üìª Escuchar en Vivo (ON)";
                btn.classList.add('live-btn-active');
            } else {
                stopLiveStream();
            }
        }

        // --- REPRODUCTOR DE ONDA FORENSE ---
        let waveAudioContext = null;
        let waveAudioBuffer = null;
        let waveAudioSource = null;
        let waveStartTime = 0;
        let wavePauseTime = 0;
        let isWavePlaying = false;
        let waveCurrentTime = 0;
        let waveAnimationId = null;
        let waveFileName = "";

        const canvas = document.getElementById('waveCanvas');
        const ctx = canvas.getContext('2d');
        const waveLoading = document.getElementById('waveLoading');
        const waveTitle = document.getElementById('waveTitle');
        const waveTimeDisplay = document.getElementById('waveTimeDisplay');
        const wavePlayBtn = document.getElementById('wavePlayBtn');

        function openWaveform(fileName) {
            // Pausar cualquier otro audio sonando
            document.querySelectorAll('audio').forEach(a => a.pause());
            if (liveAudioElement) stopLiveStream();

            waveFileName = fileName;
            waveTitle.innerText = "Analizando: " + decodeURIComponent(fileName);
            waveLoading.style.display = 'flex';
            document.getElementById('waveformModal').style.display = 'flex';
            document.body.classList.add('modal-open');

            // Iniciar o reanudar AudioContext (necesario por politicas de navegadores)
            if (!waveAudioContext) {
                waveAudioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (waveAudioContext.state === 'suspended') {
                waveAudioContext.resume();
            }

            // Descargar y Decodificar
            fetch('/api/audio?file=' + encodeURIComponent(fileName))
                .then(response => response.arrayBuffer())
                .then(arrayBuffer => waveAudioContext.decodeAudioData(arrayBuffer))
                .then(audioBuffer => {
                    waveAudioBuffer = audioBuffer;
                    waveLoading.style.display = 'none';
                    waveCurrentTime = 0;
                    drawWaveform();
                    updateWaveTimeDisplay();
                })
                .catch(e => {
                    console.error("Error decodificando audio", e);
                    waveLoading.innerText = "‚ùå Error al decodificar pista";
                });
        }

        function closeWaveform() {
            stopWaveform();
            document.getElementById('waveformModal').style.display = 'none';
            document.body.classList.remove('modal-open');
            waveAudioBuffer = null;
        }

        function drawWaveform() {
            if (!waveAudioBuffer) return;
            const width = canvas.width;
            const height = canvas.height;
            ctx.clearRect(0, 0, width, height);

            const data = waveAudioBuffer.getChannelData(0); // Tomar canal izquierdo/mono
            const step = Math.ceil(data.length / width);
            const amp = height / 2;

            // Calcular ancho del pixel de reproducci√≥n actual
            const duration = waveAudioBuffer.duration;
            const playHeadX = (waveCurrentTime / duration) * width;

            for (let i = 0; i < width; i++) {
                let min = 1.0;
                let max = -1.0;
                for (let j = 0; j < step; j++) {
                    const datum = data[(i * step) + j];
                    if (datum < min) min = datum;
                    if (datum > max) max = datum;
                }

                // Amplificaci√≥n M√°gica: Multiplicamos el pico para que el silencio tenga cuerpo
                const diff = max - min;
                const boostedDiff = diff * 5.0; // Boost x5

                // Si el audio es silencio puro de micr√≥fono (flatline real), dejamos que sea fino (1px)
                // Esto evitar√° que parezca una barra constante si no hay picos reales
                const drawHeight = Math.max(1, boostedDiff * amp);
                const drawY = amp - (drawHeight / 2); // Centrado vertical matem√°tico

                // Pintar rojo (ya reproducido) o verde (por reproducir)
                ctx.fillStyle = i <= playHeadX ? '#d32f2f' : '#4caf50';
                ctx.fillRect(i, drawY, 1, drawHeight);
            }

            // Dibujar l√≠nea del cabezal separada de la onda central
            ctx.fillStyle = 'white';
            // Puntero Superior
            ctx.fillRect(playHeadX - 1, 0, 3, 10);
            // Puntero Inferior
            ctx.fillRect(playHeadX - 1, height - 10, 3, 10);
        }

        function playFromWaveTime(time) {
            if (!waveAudioBuffer) return;

            waveAudioSource = waveAudioContext.createBufferSource();
            waveAudioSource.buffer = waveAudioBuffer;
            waveAudioSource.connect(waveAudioContext.destination);
            waveAudioSource.start(0, time);
            waveStartTime = waveAudioContext.currentTime - time;

            waveAudioSource.onended = () => {
                // Solo detener el estado de juego si NO estamos arrastrando
                // Si estamos arrastrando, el 'stop' es manual y temporal
                if (isWavePlaying && !isDragging) {
                    isWavePlaying = false;
                    waveCurrentTime = waveAudioBuffer.duration;
                    wavePlayBtn.innerHTML = "‚ñ∂Ô∏è PLAY";
                    cancelAnimationFrame(waveAnimationId);
                    drawWaveform();
                    updateWaveTimeDisplay();
                }
            };
        }

        function toggleWaveformPlay() {
            if (!waveAudioBuffer) return;

            if (isWavePlaying) {
                // PAUSE
                waveAudioSource.stop();
                wavePauseTime = waveCurrentTime;
                isWavePlaying = false;
                wavePlayBtn.innerHTML = "‚ñ∂Ô∏è PLAY";
                cancelAnimationFrame(waveAnimationId);
            } else {
                // PLAY
                if (waveCurrentTime >= waveAudioBuffer.duration) {
                    waveCurrentTime = 0; // Restart if at end
                }
                playFromWaveTime(waveCurrentTime);
                isWavePlaying = true;
                wavePlayBtn.innerHTML = "‚è∏ PAUSE";
                requestAnimationFrame(updateWaveformAnim);
            }
        }

        function seekWaveform(seconds) {
            if (!waveAudioBuffer) return;
            let newTime = waveCurrentTime + seconds;
            if (newTime < 0) newTime = 0;
            if (newTime > waveAudioBuffer.duration) newTime = waveAudioBuffer.duration;

            setWaveformTime(newTime);
        }

        function setWaveformTime(newTime) {
            waveCurrentTime = newTime;
            if (isWavePlaying) {
                waveAudioSource.stop();
                waveAudioSource = waveAudioContext.createBufferSource();
                waveAudioSource.buffer = waveAudioBuffer;
                waveAudioSource.connect(waveAudioContext.destination);
                waveAudioSource.start(0, waveCurrentTime);
                waveStartTime = waveAudioContext.currentTime - waveCurrentTime;
            } else {
                wavePauseTime = waveCurrentTime;
            }
            drawWaveform();
            updateWaveTimeDisplay();
        }

        function stopWaveform() {
            if (isWavePlaying && waveAudioSource) {
                waveAudioSource.stop();
            }
            isWavePlaying = false;
            wavePlayBtn.innerHTML = "‚ñ∂Ô∏è PLAY";
            cancelAnimationFrame(waveAnimationId);
        }

        function updateWaveformAnim() {
            if (isWavePlaying) {
                waveCurrentTime = waveAudioContext.currentTime - waveStartTime;
                if (waveCurrentTime > waveAudioBuffer.duration) {
                    waveCurrentTime = waveAudioBuffer.duration;
                }
                drawWaveform();
                updateWaveTimeDisplay();
                requestAnimationFrame(updateWaveformAnim);
            }
        }

        function updateWaveTimeDisplay() {
            if (!waveAudioBuffer) return;
            const formatTime = (time) => {
                const mins = Math.floor(time / 60).toString().padStart(2, '0');
                const secs = Math.floor(time % 60).toString().padStart(2, '0');
                return `${mins}:${secs}`;
            };
            waveTimeDisplay.innerText = `${formatTime(waveCurrentTime)} / ${formatTime(waveAudioBuffer.duration)}`;
        }

        // --- L√ìGICA DE SCRUBBING (DRAG-TO-SEEK) ---
        let isDragging = false;

        function handlePointerDown(e) {
            if (!waveAudioBuffer) return;
            isDragging = true;
            // Opcional: pausar temporalmente sin perder el control de Play
            if (isWavePlaying) waveAudioSource.stop();
            handlePointerMove(e); // Procesar el salto inicial instant√°neo
        }

        function handlePointerMove(e) {
            if (!isDragging || !waveAudioBuffer) return;
            const rect = canvas.getBoundingClientRect();
            // Soporte para Mouse (clientX) y Touch (touches[0].clientX)
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const x = clientX - rect.left;
            let ratio = x / rect.width;

            // Delimitar m√°rgenes de seguridad matem√°ticos
            if (ratio < 0) ratio = 0;
            if (ratio > 1) ratio = 1;

            const newTime = ratio * waveAudioBuffer.duration;

            // Actualizaci√≥n fantasma-fluida de los visuales mientras se arrastra (Sin disparar AudioContext pesado)
            waveCurrentTime = newTime;
            // Si estaba jugando y lo paramos, ajustamos wavePauseTime.
            wavePauseTime = waveCurrentTime;
            drawWaveform();
            updateWaveTimeDisplay();
        }

        function handlePointerUp() {
            if (!isDragging || !waveAudioBuffer) return;
            isDragging = false;
            // El dedo se ha levantado. Consolidar la orden real al motor de sonido
            // Solo ordenamos reproducir de nuevo si ya estaba el play activo antes de arrastrar
            if (isWavePlaying) {
                // Reanudamos la reproducci√≥n real en el nuevo tiempo
                playFromWaveTime(waveCurrentTime);
            }
        }

        // Oyentes para Rat√≥n (Desktop Mac/PC)
        canvas.addEventListener('mousedown', handlePointerDown);
        canvas.addEventListener('mousemove', handlePointerMove);
        canvas.addEventListener('mouseup', handlePointerUp);
        canvas.addEventListener('mouseleave', handlePointerUp);

        // Oyentes para T√°ctil Nativo (Xiaomi/iPhone)
        canvas.addEventListener('touchstart', (e) => {
            // e.preventDefault(); // Opcional, evitar scroll del modal si pulsas en el canvas
            handlePointerDown(e);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault(); // Obligatorio para evitar el scroll "Banda Goma" del navegador en Y
            handlePointerMove(e);
        }, { passive: false });

        canvas.addEventListener('touchend', handlePointerUp);

        // Polling agresivo para sensaci√≥n de tiempo real fluido en Dashboard general
        setInterval(updateDashboard, 200);

        // Cargar historial al iniciar
        loadHistory();
    </script>

</body>

</html>